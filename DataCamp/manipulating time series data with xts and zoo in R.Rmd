---
title: "manipulating time series data with xts and zoo in R"
author: "Daniel Pinedo"
date: "10/24/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Introducing xts and zoo objects**
___
- What is xts?
  - eXtensible Time Series
  - An extended zoo object
  - Index + Matrix
  - Times + Observations
  
- The xts constructor
  - tzone: time zone of your series
  - unique: forces times to be unique
  - index is in increasing order of time
  
- Special xts behavior
  - xts is a matrix with associated times for each observation
  - subsets preserve matrix form
  - attributes are preserved
    - i.e. a time-stamp that was acquired
  - xts is a subclass of zoo
  
- Deconstructing xts
  - use internal components
  - *coredata(x)* is used to extract the data component
  - *index(x)* to extract the index a.k.a. times
___

**More than a matrix**

It is best to think of xts objects as normal R matrices, but with special powers. These powers let you manipulate your data as a function of time, as your data is now self-aware of when it exists in time. Before we can start to exploit these powers, it will be helpful to see how xts objects relate to their base-R relatives.

In this exercise, you will get a feel for xts and how it behaves like a matrix object. The xts object ex_matrix and matrix object core have been pre-loaded for you.
```
# Load xts
library(xts)

# View the structure of ex_matrix
str(ex_matrix)

# Extract the 3rd observation of the 2nd column of ex_matrix
ex_matrix[3, 2]

# Extract the 3rd observation of the 2nd column of core 
core[3, 2]

######################################################
 View the structure of ex_matrix
str(ex_matrix)
An 'xts' object on 2016-06-01/2016-06-03 containing:
  Data: num [1:3, 1:2] 1 1 1 2 2 2
  Indexed by objects of class: [Date] TZ: UTC
  xts Attributes:  
List of 1
 $ createdOn: POSIXct[1:1], format: "2020-10-24 18:20:48"

 Extract the 3rd observation of the 2nd column of ex_matrix
ex_matrix[3, 2]
           [,1]
2016-06-03    2

 Extract the 3rd observation of the 2nd column of core 
core[3, 2]
[1] 2
######################################################

```

**Your first xts object**
xts objects are simple. Think of them as a matrix of observations combined with an index of corresponding dates and times.

  xts = matrix + times
  
The main xts constructor takes a number of arguments, but the two most important are x for the data and order.by for the index. x must be a vector or matrix. order.by is a vector which must be the same length or number of rows as x, be a proper time or date object (very important!), and be in increasing order.

xts also allows you to bind arbitrary key-value attributes to your data. This lets you keep metadata about your object inside your object. To add these at creation, you simply pass additional name = value arguments to the xts() function.

Since we are focusing here on the mechanics, we'll use random numbers as our data so we can focus on creating the object rather than worry about its contents.
```{r}
p_load(xts)
# Create the object data using 5 random numbers
data <- rnorm(5)

# Create dates as a Date class object starting from 2016-01-01
dates <- seq(as.Date("2016-01-01"), length = 5, by = "days")

# Use xts() to create smith
smith <- xts(x = data, order.by = dates)

# Create bday (1899-05-08) using a POSIXct date class object
bday <- as.POSIXct("1899-05-08")

# Create hayek and add a new attribute called born
hayek <- xts(x = data, order.by = dates, born = bday)

```

Now that you know how to create a very simple xts object, you are ready to see what the object looks like inside.

**Deconstructing xts**
Now that you can create xts objects, your next task is to examine an xts object from the inside.

At the core of both xts and zoo is a simple R matrix with a few additional attributes. The most important of these attributes is the index. The index holds all the information we need for xts to treat our data as a time series.

When working with time series, it will sometimes be necessary to separate your time series into its core data and index attributes for additional analysis and manipulation. The core data is the matrix portion of xts. You can separate this from the xts object using *coredata()*. The index portion of the xts object is available using the *index()* function. Note that both of these functions are methods from the zoo class, which xts extends.

In this exercise you will use these built-in functions to extract both the internal matrix data and internal index from your sample xts object. You will use the hayek time series you created in the last exercise to practice these new functions.
```{r}
# Extract the core data of hayek
hayek_core <- coredata(hayek)

# View the class of hayek_core
class(hayek_core)

# Extract the index of hayek
hayek_index <- index(hayek)

# View the class of hayek_index
class(hayek_index)
```

**Time based indices**
xts objects get their power from the index attribute that holds the time dimension. One major difference between xts and most other time series objects in R is the ability to use any one of various classes that are used to represent time. Whether POSIXct, Date, or some other class, xts will convert this into an internal form to make subsetting as natural to the user as possible.

a <- xts(x = 1:2, as.Date("2012-01-01") + 0:1)
a[index(a)]

We'll get into more detail on subsetting xts objects in a later chapter. For now you can simply use date objects to index appropriate rows from your time series. You can think of this as effectively matching the rownames you see in the object. This works as anticipated for time objects because the rownames are really dates!

For this exercise you'll create two time series using two different time classes. You will then subset each object using the other object's index.
```{r}
# Create dates
dates <- as.Date("2016-01-01") + 0:4

# Create ts_a
ts_a <- xts(x = 1:5, order.by = dates)

# Create ts_b
ts_b <- xts(x = 1:5, order.by = as.POSIXct(dates))

# Extract the rows of ts_a using the index of ts_b
ts_a[index(ts_b)]

# Extract the rows of ts_b using the index of ts_a
ts_b[index(ts_a)]

```

The versatile structure of xts objects makes subsetting them very intuitive.

**Importing, exporting and converting time series**
___

**Converting xts objects**
It is often necessary to convert between classes when working with time series data in R. Conversion can be required for many reasons, but typically you'll be looking to use a function that may not be time series aware or you may want to use a particular aspect of xts with something that doesn't necessarily need to be a full time series.

Luckily, it is quite easy to convert back and forth using the standard as.* style functionality provided in R (for example, as.POSIXct() or as.matrix()).

xts provides methods to convert all of the major objects you are likely to come across. Suitable native R types like matrix, data.frame, and ts are supported, as well as contributed ones such as timeSeries, fts and of course zoo. as.xts() is the workhorse function to do the conversions to xts, and similar functions will provide the reverse behavior.

To get a feel for moving data between classes, let's try a few examples using the Australian population ts object from R named austres.
```{r}
# Convert austres to an xts object called au
au <- as.xts(austres)

# Then convert your xts object (au) into a matrix am
am <- as.matrix(au)

# Inspect the head of am
head(am)

# Convert the original austres into a matrix am2
am2 <- as.matrix(austres)

# Inspect the head of am2
head(am2)

```

Converting objects to and from the xts class is critical for manipulating time series data and couldn't be easier than with the as.xts() command.

**Importing data**
You can now convert data to xts using as.xts(). However, in most real world applications you will often need to read raw data from files on disk or the web. This can be challenging without knowing the right commands.

In the first part of this exercise, you will start by reading a csv file from disk using the base-R read.csv. After you read the data, the next step is to convert it to xts. Here you will be required to use the xts() constructor as well as deal with converting non-standard dates into something that xts understands.

In part two of this exercise, you will read the same data into a zoo object using read.zoo and then convert the zoo object into an xts object.

The data in this exercise are quite simple, but will require some effort to properly import and clean. The full name of the file you will be working with has been saved as the value of tmp_file. On disk, the data look like:

a,b
1/02/2015, 1, 3
2/03/2015, 2, 4
```
# Create dat by reading tmp_file
dat <- read.csv(tmp_file)

# Convert dat into xts
xts(dat, order.by = as.Date(rownames(dat), "%m/%d/%Y"))

# Read tmp_file using read.zoo and as.xts
dat_zoo <- read.zoo(tmp_file, index.column = 0, sep = ",", format = "%m/%d/%Y")

# Read tmp_file using read.zoo and as.xts
dat_xts <- as.xts(dat_zoo)

```

You just successfully generated xts objects from raw data. That's quite an accomplishment!

**Exporting xts objects**
Now that you can read raw data into xts and zoo objects, it is only natural that you learn how to reverse the process.

There are two main use cases for exporting xts objects. First, you may require an object to persist across sessions for use in later analysis. In this case, it is almost always best to use saveRDS() and readRDS() to serialize single R objects.

Alternatively, you may find yourself needing to share the results of your analysis with others, often expecting the data to be consumed by processes unaware of both R and xts. Most of us would prefer not to think of this horrible fate for our data, but the real world mandates that we at least understand how this works.

One of the best ways to write an xts object from R is to use the zoo function write.zoo(). In this exercise you'll take your temporary data and write it to disk using write.zoo().
```
# Convert sunspots to xts using as.xts().
sunspots_xts <- as.xts(sunspots)

# Get the temporary file name
tmp <- tempfile()

# Write the xts object using zoo to tmp 
write.zoo(sunspots_xts, sep = ",", file = tmp)

# Read the tmp file. FUN = as.yearmon converts strings such as Jan 1749 into a proper time class
sun <- read.zoo(tmp, sep = ",", FUN = as.yearmon)

# Convert sun into xts. Save this as sun_xts
sun_xts <- as.xts(sun)
```

You've now mastered the basics of generating and exporting xts objects. Proceed to the next chapter to explore how to use these objects!

**Introducing time based queries**
___
- ISO 8601:2004
  - international standard for date and time
  - left to right from most to least significant digit
  - "YYYY-MM-DDTHH:MM:SS" format
    - year only is OK
- xts support of ISO 8601:2004
  - one and two sided intervals "2004" & "2001/2015"
  - truncated representation "201402/03"
  - time support "2014-02-22 08:30:00"
  - repeating intervals "T08:00/T09:900"
___

**Querying for dates**
One of the most powerful aspects of working with time series in xts is the ability to quickly and efficiently specify dates and time ranges for subsetting.

Date ranges can be extracted from xts objects by simply specifying the period(s) you want using special character strings in your subset.

```
A["20090825"]       ## Aug 25, 2009
A["201203/201212"]  ## Mar to Dec 2012
A["/201601"]        ## Up to and including January 2016
```

For this exercise you will create a simple but very common query. Extract a range of dates using the ISO-8601 feature of xts. After successfully extracting a full year, you will then create a subset of your new object with specific start and end dates using this same notation.

Let's find some time!
```
# Select all of 2016 from x
x_2016 <- x["2016"]

# Select January 1, 2016 to March 22, 2016
jan_march <- x["2016/2016-03-22"]

# Verify that jan_march contains 82 rows
82 == length(jan_march)

######################################################
[1] TRUE
######################################################
```

Subsetting a range is a useful way to get a snapshot of a larger time series object.

**Extracting recurring intraday intervals**
The most common time series data "in the wild" is daily. On occasion, you may find yourself working with **intraday data**, which contains both dates and times. In this case it is sometimes necessary to view only a subset of time for each day over multiple days. Using `xts`, you can slice days easily by using special notation in the `i =` argument to the single bracket extraction (i.e. `[i, j]`).

As you learned in the previous exercise, the trick to this is to not specify explicit dates, but rather to use the special **T/T** notation designed for intraday repeating intervals.

```
# Intraday times for all days
NYSE["T09:30/T16:00"] 
```
In this exercise, you will extract recurring morning hours from the time series `irreg`, which holds irregular data from the month of January 2010. Remember, you can always use the R console to experiment with `irreg` or to view the help pages with `?xts`.

```
# Extract all data between 8AM and 10AM
morn_2010 <- irreg["T08:00/T10:00"]

# Extract the observations for January 13th, 2010
morn_2010["2010-01-13"]

######################################################
                    [,1]
2010-01-13 08:07:00   41
2010-01-13 09:28:00   42
######################################################
```

Precision subsetting is a useful tool for exploring time series data.

**Alternative extraction techniques**
___
- row selection with time
  - integer indexing
    - `x[c(1, 2, 3), ]`
  - logical vectors
    - `x[index(x) > "2016-08-20"]`
  - date objects (Date, POSIXct, etc.)
    ```
    dates <- as.POSIXct(c("2016-06-25", "2016-06-27"))
    x[dates]
    ```
- modifying time series
  - same flexibility as subsetting
    - ISO 8601, integers, logicals, and date objects
  - `which.i = TRUE` creates an integer vector corresponding to times
    ```
    index <- x["2007-06-26/2007-06-28", which.i = TRUE]
    index
    ```
    `2 3 4`
- key behaviors
  - all subsets preserve matrix (`drop = FALSE`)
  - order is preserved
  - binary search and memcpy are faster than base R!
  - index and xts attributes are preserved
___

**Row selection with time objects**
Often you may need to subset an existing time series with a set of Dates, or time-based objects. These might be from `as.Date()`, `as.POSIXct()`, or a variety of other classes. In this exercise you'll explore how, given an `xts` object `x`, it is possible to extract relevant observations using a vector of dates in brackets.

The objects `x` and `dates` have been pre-loaded in your workspace.

```
# Subset x using the vector dates
x[dates]

######################################################
           [,1]
2016-06-04    3
2016-06-08    7
######################################################

# Subset x using dates as POSIXct
x[as.POSIXct(dates)]

######################################################
           [,1]
2016-06-04    3
2016-06-08    7
######################################################
```

Subsetting using a vector of dates is another skill that will serve you well when working with xts objects.

**Update and replace elements**
Replacing values in `xts` objects is just as easy as extracting them. You can use either ISO-8601 strings, date objects, logicals, or integers to locate the rows you want to replace. One reason you may want to do this would be to replace known intervals or observations with `NA`, say due to a malfunctioning sensor on a particular day or a set of outliers given a holiday.

For individual observations located sporadically throughout your data dates, integers or logical vectors are a great choice. For continuous blocks of time, ISO-8601 is the preferred method.

In this exercise, you'll continue using the vector `dates` from the previous exercise to modify your `x` object. Both are already loaded in your workspace.

```
# Replace the values in x contained in the dates vector with NA
x[dates] <- NA

# Replace all values in x for dates starting June 9, 2016 with 0
x["2016-06-09/"] <- 0

# Verify that the value in x for June 11, 2016 is now indeed 0
x["2016-06-11"]

######################################################
           [,1]
2016-06-11    0
######################################################

```

As you can see, there is no shortage of methods for subsetting xts objects.

**Methods to find periods in your data**
___
- finding times of interest
  - R uses `head()` and `tail` to look at the start or end of a series
  - xts implements 2 similar functions with respect to time
    - uses a flexible notion of time
    - i.e. "last 3 days" or "first 6 weeks"
  - these are the `first()` and `last()` functions
___

**Find the first or last period of time**
Sometimes you need to locate data by *relative* time. Something that is easier said than put into code. This is equivalent to requesting the head or tail of a series, but instead of using an absolute offset, you describe a relative position in time. A simple example would be something like the *last 3 weeks* of a series, or the *first day of current month*.

Without a time aware object, this gets quite complicated very quickly. Luckily, `xts` has the necessary prerequisites built in for you to use with very little learning required. Using the **first()** and **last()** functions it is actually quite easy!

For this exercise, you'll extract relative observations from a data set called `temps`, a time series of summer temperature data from Chicago, IL, USA.
```
# Create lastweek using the last 1 week of temps
lastweek <- last(temps, "1 week")

# Print the last 2 observations in lastweek
last(lastweek, 2)

######################################################
           Temp.Max Temp.Mean Temp.Min
2016-07-15       75        72       60
2016-07-16       79        69       60
######################################################

# Extract all but the first two days of lastweek
first(lastweek, "-2 days")

######################################################
           Temp.Max Temp.Mean Temp.Min
2016-07-13       86        78       68
2016-07-14       89        80       68
2016-07-15       75        72       60
2016-07-16       79        69       60
######################################################
```

Relative subsetting with `first()` and `last()` can be a valuable way to look at the most recent data in your xts object.

**Combining first and last**
Now that you have seen how to extract the first or last chunk of a time series using natural looking language, it is only a matter of time before you need to get a bit more complex.

In this exercise, you'll extract a very specific subset of observations by linking together multiple calls to `first()` and `last()`.

```
# Last 3 days of first week
last(first(Temps, '1 week'), '3 days') 
```
You will reconfigure the example above using the `temps` data from the previous exercise. The trick to using such a complex command is to work from the inside function, out.
```
# Extract the first three days of the second week of temps
first(last(first(temps, "2 weeks"), "1 week"), "3 days")

######################################################
           Temp.Max Temp.Mean Temp.Min
2016-07-04       80        76       69
2016-07-05       90        79       68
2016-07-06       89        79       70
######################################################
```

Subsetting with `first()` and `last()` can get complicated quickly!

**Math operations using xts**
___
- key features
  - xts is naturally a matrix
  - math operations are on the **intersection** of times
    - only these intersections will be used
  - sometimes it is necessary to drop the xts class
    - argument `drop = TRUE`, `coredata()` or `as.numeric()`
  - special handling required for **union** of dates
- out of box ops (+,-, *, /)
- operations on the union
  - it may be necessary to use all observations
___

**Matrix arithmetic - add, subtract, multiply, and divide in time!**
`xts` objects respect time. By design when you perform any binary operation using two `xts` objects, these objects are first aligned using the intersection of the indexes. This may be surprising when first encountered.

The reason for this is that you want to preserve the point-in-time aspect of your data, assuring that you don't introduce accidental look ahead (or look behind!) bias into your calculations.

What this means in practice is that you will sometimes be tasked with handling this behavior if you want to preserve the dimensions of your data.

Your options include:

  - Use `coredata()` or `as.numeric()` (drop one to a matrix or vector).
  - Manually shift index values - i.e. use `lag()`.
  - Reindex your data (before or after the calculation).
  
In this exercise, you'll look at the normal behavior, as well as an example using the first option. For now you will use two small objects `a` and `b`. Examine these objects in the console before you start.
```{r}
a <- xts(x = rep(1, 3), order.by = as.Date("2015-01-24") + 0:2)
names(a) <- "a"
a
cat("----", "\n")

b <- xts(x = 2, order.by = as.Date("2015-01-24"))
names(b) <- "b"
b
cat("----", "\n")

# Add a and b
cat("a + b", "\n")
a + b
cat("----", "\n")

# Add a with the numeric value of b
cat("a + as.numeric(b)", "\n")
a + as.numeric(b)

```

As you can see, adding two xts objects returns only the dates common to both. Adding a numeric to an xts object is a bit more intuitive.

**Math with non-overlapping indexes**
The previous exercise illustrated the ins and outs of doing basic math with xts objects. At this point you are aware that `xts` respects time and will only return the intersection of times when doing various mathematical operations.

We alluded to another way to handle this behavior in the last exercise. Namely, re-indexing your data before an operation. This makes it possible to preserve the dimensions of your data by leveraging the same mechanism that `xts` uses internally in its own `Ops` method (the code dispatched when you call `+` or similar).

The third way involves modifying the two series you want by assuring you have some union of dates - the dates you require in your final output. To do this you will need a few functions that won't be dealt with in depth until Chapter 3, but are very useful here.

`merge(b, index(a))`

Don't worry if you aren't yet familiar with `merge()`. This exercise may be easier if you just follow along with the instructions.
```{r}
a
cat("----", "\n")

b
cat("----", "\n")

# Add a to b, and fill all missing rows of b with 0
cat("a + merge(b, index(a), fill = 0)", "\n")
a + merge(b, index(a), fill = 0)
cat("----", "\n")

# Add a to b and fill NAs with the last observation
cat("a + merge(b, index(a), fill = na.locf)", "\n")
a + merge(b, index(a), fill = na.locf)
```

Math with xts objects isn't too difficult once you understand the basics.

**Merging time series**
___
- introducing merge()
  - combine series by **column**
  - `cbind()` and `merge()`
  - Database style joins on index (i.e. by time)
    - inner, outer, left, and right joins
  - fill argument handles missingness
- introducing rbind()
  - combine series by **row**
  - rows are inserted in time order
  - all rows in `rbind()` must have a time
  - the number of columns must match
___

**Combining xts by column with merge**
`xts` makes it easy to join data by column and row using a few different functions. All results will be correctly ordered in time, regardless of original frequencies or date class. One of the most important functions to accomplish this is merge(). It takes one or more series and joins them by column. It's also possible to combine a series with a vector of dates. This is especially useful for normalizing observations to a fixed calendar.

`merge()` takes three key arguments which we will emphasize here. First is the `...`, which lets you pass in an arbitrary number of objects to combine. The second argument is `join`, which specifies how to join the series - accepting arguments such as `inner` or `left`. This is similar to a relational database join, only here, the *index* is what we join on. The final argument for this exercise is `fill`. This keyword specifies what to do with the new values in a series if there is missingness introduced as a result of the merge.

```
# Basic argument use
merge(a, b, join = "right", fill = 9999)
```

For this exercise, you will explore some of the different join types to get a feel for using `merge()`. The objects `a` and `b` have been pre-loaded into your workspace.
```
>
a
                    a
2016-06-05 -1.2070657
2016-06-08  0.2774292
2016-06-09  1.0844412
2016-06-13 -2.3456977

>
b
                    b
2016-06-05  0.4291247
2016-06-06  0.5060559
2016-06-08 -0.5747400
2016-06-09 -0.5466319

# Perform an inner join of a and b
merge(a, b, join = "inner")

######################################################
                    a          b
2016-06-05 -1.2070657  0.4291247
2016-06-08  0.2774292 -0.5747400
2016-06-09  1.0844412 -0.5466319
######################################################

# Perform a left-join of a and b, fill missing values with 0
merge(a, b, join = "left", fill = 0)

######################################################
                    a          b
2016-06-05 -1.2070657  0.4291247
2016-06-08  0.2774292 -0.5747400
2016-06-09  1.0844412 -0.5466319
2016-06-13 -2.3456977  0.0000000
######################################################

```

Merging xts objects by column comes in handy when preparing data for time series analysis.

**Combining xts by row with rbind**
Now that you have merged data by column, you will be happy to know it's just as easy to add new rows to your data.

`xts` provides its own S3 method to the base `rbind()` generic function. The `xts` **rbind** function is much simpler than `merge()`. The only argument that matters is `...`, which takes an arbitrary number of objects to bind. What *is* different is that rbind requires a time series, since we need to have timestamps for R to know where to insert new data.

For this exercise you will update your `temps` data with three new observations. One will be before the series started and two will be after. Pay attention to your function call, does order matter?

In your workspace, the objects `temps`, `temps_june30`, `temps_july17` and `temps_july18` are already loaded.
```
# Row bind temps_june30 to temps, assign this to temps2
temps2 <- rbind(temps, temps_june30)

# Row bind temps_july17 and temps_july18 to temps2, call this temps3
temps3 <- rbind(temps2, temps_july17, temps_july18)
```

 Because xts objects are ordered by their time index, the order of arguments in xts's `rbind()` command is unimportant.
 
 **Handling missingness**
 ___
 - fill NAs with last observation
  - l.o.c.f. means "last observation carried forward"
  ```
  na.locf(object, na.rm = TRUE, fromLast = FALSE, maxgap = Inf)
  ```
- other NA options
  - replace NAs
  ```
  na.fill(object, fill, ...)
  ```
  - remove NAs
  ```
  na.trim(object, ...) #beginning or end
  na.omit(object, ...) #all
  ```
  - interpolate NAs
  ```
  na.approx(object, ...)
  ```
    - uses index spacing to linearly approximate the missing values
 ___
 
**Fill missing values using last or previous observation**
As you've encountered already, it's not uncommon to find yourself with missing values (i.e. `NA`s) in your time series. This may be the result of a data omission or some mathematical or merge operation you do on your data.

The `xts` package leverages the power of `zoo` for help with this. `zoo` provides a variety of missing data handling functions which are usable by `xts`.

In this exercise you will use the most basic of these, **na.locf()**. This function takes the last observation carried forward approach. In most circumstances this is the correct thing to do. It both preserves the last known value and prevents any look-ahead bias from entering into the data.

You can also apply *next observation carried backward* by setting fromLast = TRUE.

```
# Last obs. carried forward
na.locf(x)                

# Next obs. carried backward
na.locf(x, fromLast = TRUE) 
```

```
# Fill missing values in temps using the last observation
temps_last <- na.locf(temps)

# Fill missing values in temps using the next observation
temps_next <- na.locf(temps, fromLast = TRUE)
```

As you can see, the `na.locf()` command is useful for replacing missing values in xts objects.

**NA interpolation using na.approx()**
On occasion, a simple carry forward approach to missingness isn't appropriate. It may be that a series is missing an observation due to a higher frequency sampling than the generating process. You might also encounter an observation that is in error, yet expected to be somewhere *between* the values of its neighboring observations.

These are scenarios where interpolation is useful. `zoo` provides a powerful tool to do this. Based on simple linear interpolation between points, implemented with **na.approx()** the data points are approximated using the distance between the *index* values. In other words, the estimated value is linear *in time*.

For this exercise, you'll use a smaller `xts` version of the Box and Jenkin's **AirPassengers** data set that ships with R. We've removed a few months of data to illustrate various fill techniques.

One takeaway, aside from getting a feel for the functions, is to see how various fill techniques impact your data, and especially how it will impact your understanding of it.

Caveat Emptor!

The `AirPassengers` data set is available in your workspace as `AirPass`.
```
# Interpolate NAs using linear approximation
na.approx(AirPass)
```

Linear interpolation is a straightforward way to account for missingness, although it is up to you to determine its applicability.

**Lags and differences**
___
- Seasonality and stationarity
  - seasonality is a repeating pattern
  - stationarity refers to some bound of the series
  - these patterns are often compared
  - how to get around a misalignment of the series?
- Lagging a time series
  - used to align time series for comparisons
  - `lag()` will shift observations in time
  ```
  lag(x, k = 1, na.pad = TRUE, ...)
  ```
  - `k` controls the number of lags
  - `na.pad` controls NA introduction
  - with xts, **positive** `k` shifts values forward (baseR and zoo have oppostive behavior!!)
- Differencing series
  - convert levels to changes (i.e. deltas)
  ```
  diff(x, lag = 1, differences = 1,
    arithmetic = TRUE,
    log = FALSE,
    na.pad = TRUE, ...)
  ```
  - `log` controls which observations
  - `arithmetic` vs. `log` calculations
___

**Combine a leading and lagging time series**
Another common modification for time series is the ability to lag a series. Also known as a backshift operation, it's typically shown in literature using $L^k$ notation, indicating a transformation in time $L^kX=X_{tâˆ’k}$. This lets you see observations like yesterday's value in the context of today.

Both `zoo` and `xts` implement this behavior, and in fact extend it from the `ts` original in R. There are two major differences between `xts` and `zoo` implementations that you need to be aware of. One is the *direction* of the lag for a given `k`. The second is how *missingness* is handled afterwards.

For historical reasons in R, `zoo` uses a convention for the sign of `k` in which negative values indicate `lags` and positive values indicate *leads*. That is, in `zoo` `lag(x, k = 1)` will shift future values one step back in time. This is inconsistent with the vast majority of the time series literature, but is consistent with behavior in base R. `xts` implements the exact opposite, namely for a positive `k`, the series will shift the last value in time one period forward; this is consistent with intuition, but quite different than `zoo`.

In this exercise, you will construct a single `xts` object with three columns. The first column is data one day ahead, the second column is the original data, and the third column is the one day behind - all using `xts`. A simple `xts` object, `x`, has been loaded into your workspace.

```
# Your final object
cbind(lead_x, x, lag_x)
```

```{r}
x <- xts(x = seq(5, length = 5), order.by = as.Date("2020-10-20") + 0:4)
names(x) <- "x"
x
cat("----", "\n")

# Create a leading object called lead_x
lead_x <- lag(x, k = -1)
names(lead_x) <- "lead_x"

# Create a lagging object called lag_x
lag_x  <- lag(x, k = 1)
names(lag_x) <- "lag_x"

# Merge your three series together and assign to z
z <- merge(lead_x, x, lag_x)
z
```

Generating leads and lags can help you visualize trends in your time series data over time.

**Calculate a difference of a series using diff*()**
Another common operation on time series, typically on those that are non-stationary, is to take a **difference** of the series. The number of differences to take of a series is an application of recursively calling the difference function *n* times.

A simple way to view a single (or "first order") difference is to see it as `x(t) - x(t-k)` where `k` is the number of lags to go back. Higher order differences are simply the reapplication of a difference to each prior result.

In R, the difference operator for `xts` is made available using the **diff()** command. This function takes two arguments of note. The first is the `lag`, which is the number of periods, and the second is differences, which is the order of the difference (e.g. how many times `diff()` is called).

```
# These are the same
diff(x, differences = 2)
diff(diff(x))
```
In this exercise, you will reuse the `AirPass` data from earlier in this chapter, though this time you will use the full series from 1948 to 1960.
```
# Calculate the first difference of AirPass using lag and subtraction
diff_by_hand <- AirPass - lag(AirPass)

# Use merge to compare the first parts of diff_by_hand and diff(AirPass)
merge(head(diff_by_hand), head(diff(AirPass)))

######################################################
           passengers passengers.1
1949-01-01         NA           NA
1949-02-01          6            6
1949-03-01         14           14
1949-04-01         -3           -3
1949-05-01         -8           -8
1949-06-01         14           14
######################################################

# Calculate the first order 12 month difference of AirPass
diff(AirPass, lag = 12, differences = 1)

######################################################
           passengers
1949-01-01         NA
1949-02-01         NA
...
1950-01-01          3
1950-02-01          8
...
1952-01-01         26
1952-02-01         30
...
1954-02-01         -8
1954-03-01         -1
...
1954-06-01         21
1954-07-01         38
1954-08-01         21
######################################################
```

As you can see, differencing your series is only one step more complex than generating lags and leads.

**Apply functions by time**
___
- Topics
  - applying functions on discrete periods or intervals
  - two main approaches
    - `period.apply()`
    - `split`
- Apply by period
  ```
  period.apply(x, INDEX, FUN, ...)
  ```
  - `period.apply()` extends R's apply functions to time
  - pass an object `x` to be modified
  - `INDEX` is the vector of **end points** of a period
  - `FUN` is the function to apply
  - additional arguments are passed to `FUN` (if needed)
- Finding endpoints
  ```
  endpoints(x, on = "years")
  ```
  - defined as the index of the last observation per interval
  - intervals are defined with the on argument
    - uses "days, "years," "quarters," etc.
  - *always** starts on 0 and ends on the last observation
___

**Find intervals by time in xts**
One of the benefits to working with time series objects is how easy it is to apply functions by time.

The main function in `xts` to facilitate this is [endpoints()](https://www.rdocumentation.org/packages/xts/topics/endpoints). It takes a time series (or a vector of times) and returns the locations of the last observations in each interval.

For example, the code below locates the last observation of each year for the `AirPass` data set.

```
endpoints(AirPass, on = "years")
[1] 0 12 24 36 48 60 72 84 96 108 120 132 144
```
The argument `on` supports a variety of periods, including `"years"`, `"quarters"`, `"months"`, as well as intraday intervals such as `"hours"`, and `"minutes"`. What is returned is a vector starting with 0 and ending with the extent (last row) of your data.

In addition to each period, you can find the $K_{th}$ period by utilizing the `k` argument. For example, setting the arguments of your `endpoints()` call to `on = "weeks", k = 2`, would generate the final day of every other week in your data. Note that the last value returned will *always* be the length of your input data, even if it doesn't correspond to a skipped interval.

In this exercise you'll use `endpoints()` to find two sets of endpoints for the daily `temps` data.
```
# Locate the weeks
endpoints(temps, on = "weeks")

######################################################
[1]  0  3 10 16
######################################################

# Locate every two weeks
endpoints(temps, on = "weeks", k = 2)

######################################################
[1]  0 10 16
######################################################
```

As you'll see in the next exercise, locating endpoints can help speed the process of aggregating time series data.

**Apply a function by time period(s)**
At this point you know how to locate the end of periods using `endpoints()`. You may be wondering what it is you do with these values.

In the most simple case you can subset your object to get the last values. In certain cases this may be useful. For example, to identify the last known value of a sensor during the hour or get the value of the USD/JPY exchange rate at the start of the day. For most series, you will want to apply a function to the values *between* endpoints. In essence, use the base function `apply()`, but used on a window of time.

To do this easily, `xts` provides the period.apply() command, which takes a time series, an index of *endpoints*, and a function.

```
period.apply(x, INDEX, FUN, ...)
```
In this exercise you'll practice using **period.apply()** by taking the weekly mean of your `temps` data. You'll also look at one of the shortcut functions that does the same thing with slightly different syntax.
```
# Calculate the weekly endpoints
ep <- endpoints(temps, on = "weeks")

# Now calculate the weekly mean and display the results
period.apply(temps[, "Temp.Mean"], INDEX = ep, FUN = mean)

######################################################
          Temp.Mean
2016-07-03  67.66667
2016-07-10  76.71429
2016-07-16  77.00000
######################################################
```

The `period.apply()` command allows you to easily calculate complex qualities of your time series data.

**Using lapply() and split() to apply functions on intervals**
Along the same lines as the previous exercise, `xts` gives you an additional mechanism to dive into periods of your data. Often it is useful to physically *split* your data into disjoint chunks by time and perform some calculation on these periods.

For this exercise you'll make use of the `xts` **split()** command to chunk your data by time. The `split()` function creates a list containing an element for each split. The `f` argument in `split()` is a character string describing the period to split by (i.e. `"months"`, `"years"`, etc.).

Here you will follow the same process you followed in the previous exercise. However, this time you will manually split your data first, and then apply the `mean()` function to each chunk. The function `lapply()` is used for the most efficient calculations. In cases where you don't want to return a time series, this proves to be very intuitive and effective.
```
# Split temps by week
temps_weekly <- split(temps, f = "weeks")

# Create a list of weekly means, temps_avg, and print this list
temps_avg <- lapply(X = temps_weekly, FUN = mean)
temps_avg

######################################################
[[1]]
[1] 67.66667

[[2]]
[1] 77.04762

[[3]]
[1] 76.38889
######################################################
```

As you can see, `period.apply()` is similar to using a combination of `split()` and `lapply()`.

**Selection by endpoints vs. split-lapply-rbind**
By now you have seen that even in `xts` there is more than one way to accomplish a task. In this exercise we'll highlight this explicitly by tackling the same challenge using two different methods. When you are on your own, you will likely find situations where one or the other will be more intuitive, but for now you should make sure you are able to do both.

Starting with the same daily series `temps`, the challenge will be to find the last observation in each week.

Note that these functions will always find the dates that are in the closed interval [start of period, end of period] even if there is no observation at the exact start or end. `xts` represents irregular time series, so it is perfectly valid to have *holes* in the data where one might expect an observation.

Using the slides and video examples as a reference, find the last observation for each week in our `temps` data.
```
# Use the proper combination of split, lapply and rbind
temps_1 <- do.call(rbind, lapply(split(temps, "weeks"), function(w) last(w, n = "1 day")))

# Create last_day_of_weeks using endpoints()
last_day_of_weeks <- endpoints(temps, "weeks")

# Subset temps using last_day_of_weeks 
temps_2 <- temps[last_day_of_weeks]

```

It never hurts to know multiple methods for selecting certain points in your time series.

**Converting periodicity**
___
- Time series aggregation
  - useful to convert a univariate series to range bars
    - OHLC: Open, High, Low, and Close
  - summary of a particular period
    - starting, maximum, minimum, and ending value
- Aggregate using xts
  ```
  to.period(x,
            period = "months",
            k = 1,
            indexAt,
            name = NULL,
            OHLC = TRUE,
            ...)
  ```
  - `period` controls aggregation period
  - `name` string renames column roots
  - `indexAt` allows for index alignment (default is end of index)
___

**Convert univariate series to OHLC data**
Aggregating time series can be a frustrating task. For example, in financial series it is common to find Open-High-Low-Close data (or **OHLC**) calculated over some repeating and regular interval.

Also known as *range* bars, aggregating a series based on some regular window can make analysis easier amongst series that have varying frequencies. A weekly economic series and a daily stock series can be compared more easily if the daily is converted to weekly.

In this exercise, you'll convert from a univariate series into OHLC series, and then convert your final OHLC series back into a univariate series using the `xts` function **to.period()**. This function takes a time-series, `x`, and a string for the `period` (i.e. `months`, `days`, etc.), in addition to a number of other optional arguments.

```
to.period(x,
          period = "months", 
          k = 1, 
          indexAt, 
          name=NULL,
          OHLC = TRUE,
          ...)
```

You will use a new data set for this exercise, `usd_eur`, a daily USD/EUR exchange rate from 1999 to August 2016, which has been loaded into your workspace.
```
# Convert usd_eur to weekly and assign to usd_eur_weekly
usd_eur_weekly <- to.period(usd_eur, period = "weeks")

# Convert usd_eur to monthly and assign to usd_eur_monthly
usd_eur_monthly <- to.period(usd_eur, period = "months")

# Convert usd_eur to yearly univariate and assign to usd_eur_yearly
usd_eur_yearly <- to.period(usd_eur, period = "years", OHLC = FALSE)
```

Aggregating over time and converting from univariate to OHLC (and vice-versa) are useful skills for time series analysis, especially with financial data.

**Convert a series to a lower frequency**
Besides converting univariate time series to OHLC series, `to.period()` also lets you convert OHLC to lower regularized frequency - something like subsampling your data.

Depending on the chosen frequency, the index class of your data may be coerced to something more appropriate to the new data. For example, when using the shortcut function `to.quarterly()`, `xts` will convert your index to the **yearqtr** class to make periods more obvious.

We can override this behavior by using the `indexAt` argument. Specifically, using `firstof` would give you the time from the beginning of the period. In addition, you can change the base name of each column by supplying a string to the argument `name`.

For this exercise we'll introduce a new dataset, the **edhec** hedge fund index data from the **PerformanceAnalytics** package.

In this exercise you will use the Equity Market Neutral time series from the `edhec` data, which we've assigned to `eq_mkt`.
```
# Convert eq_mkt to quarterly OHLC
mkt_quarterly <- to.period(eq_mkt, period = "quarters")

# Convert eq_mkt to quarterly using shortcut function
mkt_quarterly2 <- to.quarterly(eq_mkt, name = "edhec_equity", indexAt = "firstof")
```

Commands such as `to.quarterly()` provide a convenient shortcut for precisely converting your time series to a lower frequency.

**Rolling functions**
___
- Rolling windows
  - Discrete -> `lapply()`, `split()`
  - Continuous -> `rollapply()`
- Discrete rolling windows
  - `split()` to break up by period
  - `lapply()` **cumulative** functions
    - `cumsum()`, `cumprod()`, `cummin()`, `cummax()`
- Continuous rolling windows
  ```
  rollapply( data, width, FUN, ...,
            by = 1, by.column = TRUE,
            fill = if (na.pad) NA,
            na.pad = TRUE, partial = TRUE,
            align = c("right", "center", "left"))
  ```
  - `data` is your xts object
  - `width` is the window size
  - `FUN` is your function to apply
  - can add additional arguments to your function
___

**Calculate basic rolling value of series by month**
One common aggregation you may want to apply involves doing a calculation within the context of a period, but returning the interim results for each observation of the period.

For example, you may want to calculate a running month-to-date cumulative sum of a series. This would be relevant when looking at monthly performance of a mutual fund you are interested in investing in.

For this exercise, you'll calculate the cumulative annual return using the `edhec` fund data from the last exercise. To do this, you'll follow the `split()`-`lapply()`-`rbind()` pattern demonstrated below:

```
x_split <- split(x, f = "months")
x_list <- lapply(x_split, cummax)
x_list_rbind <- do.call(rbind, x_list)
```

Note the last call uses R's somewhat strange `do.call(rbind, ...)` syntax, which allows you to pass a list to `rbind` instead of passing each object one at a time. This is a handy shortcut for your R toolkit.
```
# Split edhec into years
edhec_years <- split(edhec, f = "years")

# Use lapply to calculate the cumsum for each year in edhec_years
edhec_ytd <- lapply(edhec_years, FUN = cumsum)

# Use do.call to rbind the results
edhec_xts <- do.call(rbind, edhec_ytd)
```

The **split-lapply-rbind** syntax may seem complicated, but it is a powerful way to manipulate your time series data.

**Calculate the rolling standard deviation of a time series**
Another common requirement when working with time series data is to apply a function on a rolling window of data. `xts` provides this facility through the intuitively named `zoo` function **rollapply()**.

This function takes a time series object `x`, a window size `width`, and a function `FUN` to apply to each rolling period. The `width` argument can be tricky; a number supplied to the width argument specifies the number of observations in a window. For instance, to take the rolling 10-day max of a series, you would type the following:

```
rollapply(x, width = 10, FUN = max, na.rm = TRUE)
```

Note that the above would only take the 10-day max of a series with daily observations. If the series had monthly observations, it would take the *10-month max*. Also note that you can pass additional arguments (i.e. `na.rm` to the `max` function) just like you would with `apply()`.
```
# Use rollapply to calculate the rolling 3 period sd of eq_mkt
eq_sd <- rollapply(eq_mkt, 3, sd)
```

Rolling values are a useful metric in time series data. Now that you are familiar with the core features of the xts package, the final chapter will explore a few more advanced topics using xts.

**Index, attributes, and time zones**
___
- What is the index?
  - Raw seconds since 1970-01-01 UTC
  - `tclass` or `indexClass`: attribute for extraction
  - `tzone` or `indexTZ`: attribute for time zones
  - `indexFormat`: optional display preferences
- Understanding TZ
  - describe time offset from UTC (a.k.a. Greenwich Mean Time)
  - always set your time zone to avoid surprises!
  ```
  Sys.setenv(TZ = "America/Chicago")
  Sys.setenv(TZ = "UTC")
  ```
  - know your time zones
  ```
  help(OlsonNames)    #Great read!
  ```
___

**Class attributes - tclass, tzone, and tformat**
`xts` objects are somewhat tricky when it comes to time. Internally, we have now seen that the index attribute is really a vector of numeric values corresponding to the seconds since the UNIX epoch (1970-01-01).

How these values are displayed on printing and how they are returned to the user when using the `index()` function is dependent on a few key internal attributes.

The information that controls this behavior can be viewed and even changed through a set of accessor functions detailed here:

  * The index class using [indexClass()](https://www.rdocumentation.org/packages/xts/topics/indexClass) (e.g. from Date to chron)
  * The time zone using [indexTZ()](https://www.rdocumentation.org/packages/xts/topics/indexTZ) (e.g. from America/Chicago to Europe/London)
  * The time format to be displayed via `indexFormat()` (e.g. YYYY-MM-DD)
  
In this exercise, you will practice each of these functions and view the results of your changes. To do so, you'll once again use the `temps` data that has been pre-loaded into your workspace.
```
# View the first three indexes of temps
index(temps)[1:3]

######################################################
[1] "2016-06-30 20:00:00 EDT" "2016-07-01 20:00:00 EDT"
[3] "2016-07-02 20:00:00 EDT"
######################################################

# Get the index class of temps
indexClass(temps)

######################################################
Warning message: 'indexClass' is deprecated.
Use 'tclass' instead.
See help("Deprecated") and help("xts-deprecated").

[1] "POSIXct" "POSIXt"
######################################################

# Get the timezone of temps
indexTZ(temps)

######################################################
Warning message: 'indexTZ' is deprecated.
Use 'tzone' instead.
See help("Deprecated") and help("xts-deprecated").

[1] "America/New_York"
######################################################

# Change the format of the time display
indexFormat(temps) <- "%b-%d-%Y"

# View the new format
head(temps)

######################################################
Warning message: timezone of object (America/New_York) is different than current timezone (GMT).

            Temp.Max Temp.Mean Temp.Min
Jun-30-2016       74        69       60
Jul-01-2016       78        66       56
Jul-02-2016       79        68       59
Jul-03-2016       80        76       69
Jul-04-2016       90        79       68
Jul-05-2016       89        79       70
######################################################
```

These commands allow you to quickly and easily modify the internal characteristics of your xts object.

**Time Zones (and why you should care!)**
One of the trickiest parts to working with time series in general is dealing with time zones. `xts` provides a simple way to leverage time zones on a per-series basis. While R provides time zone support in native classes `POSIXct` and `POSIXlt`, `xts` extends this power to the entire object, allowing you to have multiple time zones across various objects.

Some internal operation system functions require a time zone to do date math. If a time zone isn't explicitly set, one is chosen for you! Be careful to *always* set a time zone in your environment to prevent errors when working with dates and times.

`xts` provides the function **tzone()**, which allows you to extract or set time zones.

```
tzone(x) <- "Time_Zone"
```

In this exercise you will work with an object called `times` to practice constructing your own `xts` objects with custom time zones.
```
######################################################
>
times
 [1] "2020-10-26 01:18:00 GMT" "2020-10-26 01:19:40 GMT"
 [3] "2020-10-26 01:21:20 GMT" "2020-10-26 01:23:00 GMT"
 [5] "2020-10-26 01:24:40 GMT" "2020-10-26 01:26:20 GMT"
 [7] "2020-10-26 01:28:00 GMT" "2020-10-26 01:29:40 GMT"
 [9] "2020-10-26 01:31:20 GMT" "2020-10-26 01:33:00 GMT"
######################################################
 
# Construct times_xts with tzone set to America/Chicago
times_xts <- xts(1:10, order.by = times, tzone = "America/Chicago")

# Change the time zone of times_xts to Asia/Hong_Kong
tzone(times_xts) <- "Asia/Hong_Kong"
  
# Extract the current time zone of times_xts
tzone(times_xts)

######################################################
[1] "Asia/Hong_Kong"
######################################################
```

 As you can see, manipulating time zones in xts is relatively straightforward.
 
 **Periods, periodicity and timestamps**
 ___
 - Final topics
  - find the time an object covers
  - find periods within your object
  - account for duplicates and false precision
- periodicity()
  - identifies the regularity of data
  - answers what type of data is present
  - less useful for irregular timestamps
  - summary measure of the index
- counting periods
  - estimate number of periods (e.g. days, weeks)
  - irregular series equals irregular counting
  - counts periods greater than periodicity
- broken down time with .index*
  - time expressed as POSIXlt components
    - sec, min, hour, mday, mon, year, wday, yday, isdst
- modifying timsstamps
  - use align.time() to round time stamps to another period
  ```
  align.time(x, n = 60)   # n is in seconds
  ```
  - useful to remove observations of duplicate timestamps
  ```
  make.index.unique(x,
                    eps = 1e-06,
                    drop = TRUE,
                    fromLast = FALSE, ...)
  ```
 ___
 
**Determining periodicity**
The idea of periodicity is pretty simple: With what regularity does your data repeat? For stock market data, you might have hourly prices or maybe daily open-high-low-close bars. For macroeconomic series, it might be monthly or weekly survey numbers.

`xts` provides a handy tool to discover this regularity in your data by estimating the frequency of the observations - what we are referring to as *periodicity* - using the [periodicity()](https://www.rdocumentation.org/packages/xts/topics/periodicity) command

In this exercise, you'll try this out on a few sample data sets. In real life you might find yourself doing this as a first step to understanding your data before diving in for further analysis.
```
# Calculate the periodicity of temps
periodicity(temps)

######################################################
Daily periodicity from 2016-07-01 to 2016-07-16
######################################################

# Calculate the periodicity of edhec
periodicity(edhec)

######################################################
Monthly periodicity from 1997-01-31 to 2009-08-31
######################################################

# Convert edhec to yearly
edhec_yearly <- to.yearly(edhec)

# Calculate the periodicity of edhec_yearly
periodicity(edhec_yearly)

######################################################
Yearly periodicity from 1997-12-31 to 2009-08-31
######################################################
```

The `periodicity()` command combined with the `to.period()` set of commands gives you a simple way to manipulate your time series data.

**Find the number of periods in your data**
Often it is handy to know not just the range of your time series index, but also how many discrete *irregular* periods your time series data covers. You shouldn't be surprised to learn that `xts` provides a set of functions to do just that!

If you have a time series, it is now easy to see how many days, weeks or years your data contains. To do so, simply use the function **ndays()** and its shortcut functions `nmonths()`, `nquarters()`, and so forth, making counting *irregular* periods easy.
```
# Count the months
nmonths(edhec)

######################################################
[1] 152
######################################################

# Count the quarters
nquarters(edhec)

######################################################
[1] 51
######################################################

# Count the years
nyears(edhec)

######################################################
[1] 13
######################################################
```

You're getting the hang of these advanced topics pretty quickly.

**Secret index tools**
`xts` uses a very special attribute called `index` to provide time support to your objects. For performance and design reasons, the index is stored in a special way. This means that regardless of the *class* of your index (e.g. `Date` or `yearmon`) everything internally looks the same to `xts`. The raw index is actually a simple vector of fractional seconds since the UNIX epoch.

Normally you want to access the times you stored. `index()` does this magically for you by using your `indexClass`. To get to the raw vector of the index, you can use `.index()`. Note the critical dot before the function name.

More useful than extracting raw seconds is the ability to extract time components similar to the **POSIXlt** class, which closely mirrors the underlying POSIX internal compiled structure **tm**. This functionality is provided by a handful of commands such as `.indexday()`, `.indexmon()`, `.indexyear()`, and more.

In this exercise, you'll take a look at the weekend weather in our pre-loaded `temps` data using the **.indexwday()** command. Note that the values range from 0-6, with **Sunday equal to 0**. Recall that you can use a logical vector to extract elements of an `xts` object.
```
# Explore underlying units of temps in two commands: .index() and .indexwday()
.index(temps)
.indexwday(temps)

######################################################
.index(temps)
 [1] 1467331200 1467417600 1467504000 1467590400 1467676800 1467763200
 [7] 1467849600 1467936000 1468022400 1468108800 1468195200 1468281600
[13] 1468368000 1468454400 1468540800 1468627200

attr(,"tzone")
[1] ""
attr(,"tclass")
[1] "POSIXct" "POSIXt" 

.indexwday(temps)
 [1] 5 6 0 1 2 3 4 5 6 0 1 2 3 4 5 6
######################################################

# Create an index of weekend days using which()
index <- which(.indexwday(temps) == 0 | .indexwday(temps) == 6)

# Select the index
temps[index]

######################################################
          Temp.Max Temp.Mean Temp.Min
2016-07-02       78        66       56
2016-07-03       79        68       59
2016-07-09       81        73       67
2016-07-10       83        72       64
2016-07-16       79        69       60
######################################################
```

As you can see, these index commands have a variety of applications when it comes to subsetting your time series data.

**Modifying timestamps**
Most time series we've seen have been daily or lower frequency. Depending on your field, you might encounter higher frequency data - think intraday trading intervals, or sensor data from medical equipment.

In these situations, there are two functions in `xts` that are handy to know.

If you find that you have observations with identical timestamps, it might be useful to perturb or remove these times to allow for uniqueness. `xts` provides the function **make.index.unique()** for just this purpose. The `eps` argument, short for epsilon or small change, controls how much identical times should be perturbed, and `drop = TRUE` lets you just remove duplicate observations entirely.

On other occasions you might find your timestamps a bit *too* precise. In these instances it might be better to round up to some fixed interval, for example an observation may occur at any point in an hour, but you want to record the latest *as of* the beginning of the next hour. For this situation, the **align.time()** command will do what you need, setting the `n` argument to the number of seconds you'd like to round to.

```
make.index.unique(x, eps = 1e-4)  # Perturb
make.index.unique(x, drop = TRUE) # Drop duplicates
align.time(x, n = 60) # Round to the minute
```

In this exercise, you'll try the three use cases on an `xts` object called `z`.
```
######################################################
>
z
                            [,1]
2020-10-27 21:31:15 -1.539950042
2020-10-28 06:22:20 -0.928567035
2020-10-28 06:22:20 -0.928567035
2020-10-29 08:55:51 -0.294720447
2020-10-30 13:44:53 -0.005767173
2020-10-31 21:47:46  2.404653389
2020-11-01 04:50:25  0.763593461
2020-11-02 21:33:36 -0.799009249
2020-11-02 21:33:36 -0.799009249
2020-11-03 22:40:14 -1.147657009
2020-11-04 15:51:28 -0.289461574
2020-11-05 15:05:50 -0.299215118
######################################################

# Make z have unique timestamps
z_unique <- make.index.unique(z, eps = 1e-4)

# Remove duplicate times in z
z_dup <- make.index.unique(z, drop = TRUE)

# Round observations in z to the next hour
z_round <- align.time(z, n = 3600)
```

These final commands should round out your xts knowledge and give you the complete tools to manipulate time series data in R.

**Congratulations!**
___